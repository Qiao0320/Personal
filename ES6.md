[TOC]
****
## 简介

### 兼容性
- IE10+，Chrome，FireFox，移动端，NodeJS
- 若不支持可以编译或者转换
    - 在线转换
    - 提前编译
        > 可以使用babel或者引用browser.js（一个东西）
        > 引用browser.js时script标签的type属性为“text/babel”（属于在线转换）

### 变量
##### ES6之前的缺陷
- 没有块级作用域
- var可以重复声明
- 无法限制修改（没有常量定义）
##### 6的改进
- 不能重复声明
- let变量
- const常量
- 增加块级作用域
        for (var i = 0; i < 5; i++) {
            setTimeout(function() {
                console.log(i);
            }, 1000);
        }
    输出：5 -> 5 -> 5 -> 5 -> 5
        for (let i = 0; i < 5; i++) {
            setTimeout(function() {
                console.log(new Date, i);
            }, 1000);
        }
    输出：0 -> 1 -> 2 -> 3 -> 4
    也可以使用闭包：
        for (var i = 0; i < 5; i++) {
            (function(i){
                setTimeout(function() {
                    console.log(new Date, i);
                }, 1000);
            })(i)
        }
    输出：0 -> 1 -> 2 -> 3 -> 4

### 函数
##### 箭头函数
- 基本格式：()=>{}
    > 如果只有一个参数，'()'可以省
    > 如果只有一个return，'{}'可以省
        window.onload = ()=>{
            alert(1)
        }
    等价于
        window.onload = function(){
            alert(1)
        }
    ep：数组排序
        let arr = [1,9,78,-8,56];
        arr.sort((a,b)=>{
            return a-b
        });
        console.log(arr)
    输出：-8,1,9,56,78
    ep:简写
        let show = a=>a*2
##### 函数的参数
- 参数的展开/扩展
    > 作用：
    > 1. 收集剩余的参数,其中Rest Parameter（args）只能放在最后
        let show = function(a,b,...args){
            console.log(args)
        }
        show(1,2,3,4,5)
        输出：1,2,3,4,5
    > 2. 展开数组，展开后的效果就跟数组内容直接写出来一样
        let arr1 = [1,2,3];
        let arr2 = [4,5,6];
        let arr3 = [...arr1,...arr2]
        console.log(arr3)
        输出：[1,2,3,4,5,6]
    一起使用：
        function show(...args){
            fn(...args)
        }
        function fn(a,b){
            console.log(a+b)
        }
        show(2,3)
        输出：5
- 默认参数
        function show(a,b=1,c=2){
            console.log(a,b,c)
        }
        show(2,3)
        输出:2,3,2
### 数组
### 字符串
### 面向对象
### Promise
### yield（generator）
### 模块化

> d: 切换盘符
> dir 列出当前目录下的文件以及文件夹
> md 创建目录
> rd 删除目录
> cd.. 返回上一级
> del  del a.txt del *.txt(删除后缀名为txt的文件)

### JAVA发展

- Java Development Kit
- Java 2 SDk
- Java 语言平台版本
    > J2SE  标准版
    > J2ME  小型版
    > J2EE  企业版

#### 特点
- 跨平台（不同操作系统上有JAVA虚拟机JVM即可运行）也称为可移植性

#### JRE（JAVA Runtime Environment）
- 包括JAVA虚拟机（JVM）和JAVA程序所需的核心类库等等

#### JDK
- 开发环境，包含开发工具，也包括JRE

##0418

### 命名规则

- 包：全部小写
- 类或者接口：
    > 一个单词：首字母必须大写
    > 多个单词：每个字母首字母必须大写
- 方法或者变量
    > 一个单词：首字母小写
    > 多个单词：从第二个单词开始每个单词首字母大写
- 常量
    > 一个单词：全部大写
    > 多个单词：每个字母都大写   用下划线隔开

### 数据类型

- java是一种强类型的语言，针对每一种数据都定义了明确的数据类型
- 数据类型分类
    > 整数：byte（1字节），short（2），int（4），long（8）
    > 浮点数：float（4），double（8）
    > 字符：char（2）
    > 布尔：boolean

### 数据类型转换
- 默认转换：
    - byte，short，char-int-long-folat-doble
    - byte，short，char之间不转换，参与运算是首先转化为int类型
- 强制转换：byte c = (byte)(a+b)
- float表示的数据范围比long大
- java采用Unicode编码

### 访问修饰符区别
    作用域 | 当前类 | 同包 | 子类 | 其他
    - | :-: | :-: | :-: | :-: | :-: 
    public | √ |  √ |  √ |  √ | 
    protected | √ |  √ |  √ | X | 
    default | √ |  √ |  X |  X | 
    private | √ |  X |  X |  X | 

### 面向对象特征
- 封装
- 继承
- 多态

### 参数传递
- 只有值传递
- 基本类型：形参不影响实参
- 引用类型：不影响

### 成员变量和局部变量
- 在类中位置不同，前者在方法外，后者在方法中
- 在内存中位置不同，前者在堆内存，后者在栈内存
- 生命周期不同，前者随着对象的创建而存在，随着对象的消失而消失；后者随着方法的调用完毕而消失
- 初始化值不同，前者有默认初始化值，后者默认初始化值，必须定义数值才能使用

### 封装
- 定义：隐藏对象的属性和实现细节，仅提供对外公共访问方式
- 好处：提高代码复用性以及安全性

### this
- 当前类的对象引用
- 方法被哪个对象调用，this就指哪个对象
- 场景：解决局部变量隐藏成员变量

### 构造方法
- 给对象的数据进行舒适化
- 格式：方法名与类名相同，没有返回值类型甚至没有void，没有具体的返回值
- 注意事项：
    > 如果我没有给出构造方法，系统会自动提供一个无参构造方法
    > 如果有，会被覆盖

## 0420

### static
- 特点：
    > 随着类的加载而加载
    > 优先于对象存在
    > 被类的所有对象共享
    > 可以通过类名调用  也可以通过对象名调用（推荐使用类名调用） 静态修饰的内容一般称为与类相关的即类成员
- ​注意事项：
    > 静态方法中没有this关键字，无法引用非静态变量
    > 静态方法只能访问静态的成员变量和静态的成员方法，静态只能访问静态，费静态可以访问一切
### main方法
- public：公共的
- static：静态的。不需要创建对象，不需要创建对象，方便JVM的调用
- void：无返回值
- main：是一个常见的方法入口，几乎所有语言都是以main作为入口
- string[] args：是一个字符串数组
### Q & A
- Q:String 是最基本的数据类型吗？
    > 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；
    > 除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。
- Q:&和&&的区别？
    > &运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算;
    > &&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。
- Q:解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。
    > 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；
    > 而通过new关键字和构造器创建的对象放在堆空间；
    > 程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中；
    > 栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。
        String str = new String("hello");
    > 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。

### 开发原则
- 低耦合，高内聚
    > 类与类的关系
    > 内聚：自己完成某件事的能力
### 继承
- 多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
- 关键字：extends
- 格式： class 子类名 extends 父类名
- 好处:
    > 提高代码复用性
    > 提高代码维护性
    > 让类与类产生了关系，是多态的前提
- 弊端：
    > 类的耦合性增强
- 特点
    > java只支撑单继承，不支持多继承（C++支持多继承）
    > java 支持多层继承（继承体系）
- 注意事项
    > 子类只能继承父类的所有非私有的成员
    > 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法
- 继承中成员变量的关系
    > 子类与父类的成员变量名称不一样可以共存
    > 一样的话，顺序就近先子后父
- 继承中构造方法的关系
    > 子类中所有的构造方法默认都会访问父类的无参构造方法
    > 一样的话，顺序就近先子后父
- super
    > super代表父类存储空间的表示（理解为父类引用，可以操作父类的成员）
- 方法重写Override
    - 定义：子类中出现和父类中方法一模一样的方法
    - 注意事项：
        > 父类中私有方法不能被重写
        > 子类重写父类方法时，访问权限不能更低
        > 父类中的静态方法，重写是必须也是静态方法

- 方法重载Overload
    > 本类中出现的方法名一样，参数列表不同的方法，与返回值无关
- final
    > 修饰类，方法，变量
    > 若修饰类，无法继承
    > 若修饰方法，不能被重写
- Q: final修饰局部变量的问题
    > final可以修饰局部变量，修饰基本类型时值不能变，修饰引用类型时地址值不能变
- 多态
    - 定义：某一个食物，在不同时刻表现出来的不同状态
    - 前提：
        > 要有继承关系
        > 要有方法重写
        > 要有父类引用指向子类对象 父f=new 子（）
    - 多态中的成员访问特点
        > 成员变量：编辑看左边，运行看左边
        > 构造方法：创建子类的时候访问父类的构造方法
        > 成员方法：编辑看左边，运行看右边
        > 静态方法：编辑看左边，运行看左边，静态和类相关，算不上重写
    - 好处
        > 提高了代码的维护性
        > 提高了代码的扩展性
    - 弊端
        > 不能使用子类的特有功能
        > 若想用，把父类引用强制转换为子类的引用（向下转型）
    - 测试

